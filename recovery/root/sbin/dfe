#!/bin/bash
TMPN="/tmp/dfe_tmp"
mkdir -p $TMPN
FSTAB_PATCH_PATERNS="-m /data -r fileencryption= forcefdeorfbe= encryptable= forceencrypt= metadata_encryption= keydirectory= inlinecrypt quota wrappedkey"
CURRENT_SUFFIX=$(getprop ro.boot.slot_suffix)
case "$CURRENT_SUFFIX" in
    "_a") CURRENT_SLOT=0 ;;
    "_b") CURRENT_SLOT=1 ;;
esac
NAME_INJECT=inject
IMG="$TMPN/inject.img"

install_dfe() {
    mount_vendor
    move_files_from_vendor_hw || return 1
    if ! check_first_stage_fstab ; then
        abort
    fi
    make_inject_img "$TMPN/inject$CURRENT_SUFFIX" "inject" "${VENDOR_FOLDER}/etc/init/hw" "${VENDOR_FOLDER}/etc" || abort
    flash_inject_to_super || abort
    ramdisk_first_stage_patch $BOOT_PATCH || abort
}; export -f install_dfe

mount_vendor() {
    echo "- Starting vendor mount"
    VENDOR_BLOCK=""
    if [[ -h "/dev/block/mapper/vendor$CURRENT_SUFFIX" ]] ; then
        VENDOR_BLOCK="/dev/block/mapper/vendor$CURRENT_SUFFIX"
        echo "- $VENDOR_BLOCK: $(basename $(readlink $VENDOR_BLOCK))"
    else
        abort
    fi
    
    [[ -z "${VENDOR_BLOCK}" ]] && abort

    name_vendor_block="vendor${CURRENT_SUFFIX}" 
    full_path_to_vendor_folder=$TMPN/mapper/$name_vendor_block

    mkdir -p $full_path_to_vendor_folder
    echo "- Mounting vendor to temporary folder"
    mount -o,ro -t erofs $VENDOR_BLOCK $full_path_to_vendor_folder || abort
}; export -f mount_vendor

umount_vendor(){
        umount "$full_path_to_vendor_folder"
}; export umount_vendor

move_files_from_vendor_hw() {
    if [[ "$FSTAB_EXTENSION" == "auto" ]] ; then
        FSTAB_EXTENSION=""
    fi
    if [[ -z "$FSTAB_EXTENSION" ]] ; then 
        hardware_boot=$(getprop ro.hardware)
    else
        hardware_boot="$FSTAB_EXTENSION"
    fi
    if [[ -z "$hardware_boot" ]]; then
        hardware_boot=$(getprop ro.boot.hardware)
    fi
    if [[ -z "$hardware_boot" ]]; then
        hardware_boot=$(getprop ro.boot.hardware.platform)
    fi
    default_fstab_prop=$(getprop ro.boot.fstab_suffix)

    echo "- creating a folder structure for make_ext4fs and copying from inithw" && {
        VENDOR_FOLDER="$full_path_to_vendor_folder"
        mkdir -p $TMPN/inject${CURRENT_SUFFIX}
        mkdir -p "$TMPN/inject${CURRENT_SUFFIX}/lost+found"
        cp -af ${VENDOR_FOLDER}/etc/init/hw/* $TMPN/inject${CURRENT_SUFFIX}/
    }
    
    echo "- Search fstab by .rc files" && {
        fstab_names_check=""
        for file_find in "$TMPN/inject${CURRENT_SUFFIX}"/*.rc ; do
            if grep "mount_all" $file_find | grep "\-\-late" | grep -v "#"; then

                fstab_lines_all=$(grep mount_all $file_find | grep "\-\-late" | grep -v "#" | sort -u)
                if [[ "$default_fstab_prop" == default ]] ; then
                    default_fstab_prefixx="fstab.$hardware_boot fstab.$default_fstab_prop fstab.$(getprop ro.product.device)"
                else
                    default_fstab_prefixx="fstab.$hardware_boot fstab.$default_fstab_prop fstab.$(getprop ro.product.device) fstab.default"
                fi
                while IFS= read -r while_line_fstab; do
                    if echo "$while_line_fstab" | grep "mount_all --late" | grep -v "#"; then
                        for fstab_needed_patch in $default_fstab_prefixx; do
                            if ! echo "$fstab_names_check" | grep $fstab_needed_patch; then
                                fstab_names_check+="$fstab_needed_patch "
                            fi
                            move_fstab_from_original_vendor_and_patch "$full_path_to_vendor_folder/etc/$fstab_needed_patch"
                            return_error="$?"
                            case "$return_error" in
                            10|20)
                                if [[ "$return_error" == "10" ]] ; then
                                    final_fstab_name+="$fstab_needed_patch "
                                fi
                                sed -i '/^    mount_all --late$/s/.*/    mount_all \/vendor\/etc\/init\/hw\/fstab.'$hardware_boot' --late/g' "$file_find"
                                last_init_rc_file_for_write=$file_find
                            ;;
                            esac
                        done
                        
                    else
                        fstab_base_name__SS=$(basename "$(echo "$while_line_fstab" | awk '{print $2}')")
                        if echo "$fstab_base_name__SS" | grep "\\$"; then
                            fstab_base_name__SS=""
                            for file in $default_fstab_prefixx ; do
                                if [[ -f $full_path_to_vendor_folder/etc/$file ]] ; then
                                    fstab_base_name__SS="$file"
                                    break
                                fi
                            done
                            [[ -z "$fstab_base_name__SS" ]] && exit 81
                        fi
                        if ! echo "$fstab_names_check" | grep $fstab_base_name__SS; then
                            fstab_names_check+="$fstab_base_name__SS "
                        fi
                        new_path_fstab="$(echo "$while_line_fstab" | sed "s|[^ ]*fstab[^ ]*|/vendor/etc/init/hw/$fstab_base_name__SS|")"
                        move_fstab_from_original_vendor_and_patch "$full_path_to_vendor_folder/etc/$fstab_base_name__SS"
                        return_error="$?"
                        case "$return_error" in
                            10|20)
                                if [[ "$return_error" == "10" ]] ; then
                                    final_fstab_name+="$fstab_base_name__SS " 
                                fi
                                sed -i "s|$while_line_fstab|$new_path_fstab|g" "$file_find"
                                last_init_rc_file_for_write=$file_find
                                if $MOUNT_FSTAB_EARLY_TOO ; then
                                    sed -i "s|${while_line_fstab//"--late"/"--early"}|${new_path_fstab//"--late"/"--early"}|g" "$file_find"
                                fi
                            ;;
                        esac
                        
                    fi  
                done <<< "$fstab_lines_all"
            fi
        done
        if [[ -z "$final_fstab_name" ]] || [[ "$final_fstab_name" == "" ]] ; then
            abort
        fi
    }

}; export -f move_files_from_vendor_hw

check_first_stage_fstab() {
    echo "- first stage boot check"
    mkdir -p "$TMPN/check_boot_first_stage/"
    for boot in "vendor_boot$CURRENT_SUFFIX" "boot$CURRENT_SUFFIX" ; do
        echo "- verification $boot"
        if ! find_block -c -b $boot ; then
            echo "$boot not found"
            continue
        fi
        boot_check_folder="$TMPN/check_boot_first_stage/$boot"
        mkdir -p "$boot_check_folder/ramdisk_folder"
        vendor_boot_block=$(find_block -b $boot)
        cd "$boot_check_folder"
        if magiskboot unpack -h "$vendor_boot_block" &> /dev/null; then
            if [[ -f "$boot_check_folder/ramdisk.cpio" ]] ; then
                echo "- found $boot_check_folder/ramdisk.cpio"
                ramdisk_cpio="$boot_check_folder/ramdisk.cpio"
            elif [[ -f "$boot_check_folder/vendor_ramdisk/ramdisk.cpio" ]] ; then
                echo "- found $boot_check_folder/vendor_ramdisk/ramdisk.cpio"
                ramdisk_cpio="$boot_check_folder/vendor_ramdisk/ramdisk.cpio"
            else
                continue
            fi

            cd "$boot_check_folder/ramdisk_folder"
            if ! magiskboot cpio "$ramdisk_cpio" extract &> /dev/null; then
                echo "failed to unpack cpio, maybe it has a compression format in it"
                magiskboot decompress "$ramdisk_cpio" "$boot_check_folder/ramdisk.d.cpio"
                rm -f "$ramdisk_cpio"
                mv "$boot_check_folder/ramdisk.d.cpio" "$ramdisk_cpio"
                if ! magiskboot cpio "$ramdisk_cpio" extract &> /dev/null; then
                    continue
                fi  
            fi
            find_args=""
            for needed_add_find_arg in $final_fstab_name ; do
                if [[ -z "$find_args" ]] ; then 
                    find_args="-name $needed_add_find_arg"
                else
                    find_args+=" -or -name $needed_add_find_arg"
                fi
            done
            for fstab in $(find "$boot_check_folder/ramdisk_folder/" $find_args); do
                if grep -w "/system" $fstab | grep -q "first_stage_mount"; then
                    BOOT_PATCH+="$boot "
                fi
            done
        fi
        rm -rf "$TMPN/check_boot_first_stage/"
    done
    echo "- BOOT_PATCH: $BOOT_PATCH"
    if [[ -n "$BOOT_PATCH" ]] ; then
        return 0
    else
        return 1
    fi
}; export -f check_first_stage_fstab

ramdisk_first_stage_patch() {
    for boot in $1 ; do
        ramdisk_compress_format=""
        echo "- Patching first_stage $boot"
        boot_folder="$TMPN/ramdisk_patch/$boot"
        mkdir -p "$TMPN/ramdisk_patch/$boot/ramdisk_folder"
        boot_block=$(find_block -b $boot)
        cd $boot_folder
        magiskboot unpack -h "$boot_block" &> /dev/null
        cd "$boot_folder/ramdisk_folder"

        if [[ -f "$boot_folder/ramdisk.cpio" ]] ; then
            echo "- Unpacking $boot_folder/ramdisk.cpio"
            ramdisk_cpio="$boot_folder/ramdisk.cpio"
        elif [[ -f "$boot_folder/vendor_ramdisk/ramdisk.cpio" ]] ; then
            echo "- Unpacking $boot_folder/vendor_ramdisk/ramdisk.cpio"
            ramdisk_cpio="$boot_folder/vendor_ramdisk/ramdisk.cpio"
        else
            echo "- ramdisk.cpio not found in $boot"
            abort
        fi

        if ! magiskboot cpio "$ramdisk_cpio" extract &> /dev/null; then
            echo "- Decompressing ramdisk..."
            magiskboot decompress "$ramdisk_cpio" "$boot_folder/ramdisk.d.cpio" &>$boot_folder/log.decompress
            rm -f "$ramdisk_cpio"
            mv "$boot_folder/ramdisk.d.cpio" "$ramdisk_cpio"
            ramdisk_compress_format=$(grep "Detected format:" $boot_folder/log.decompress | sed 's/.*\[\(.*\)\].*/\1/')
        fi
        if [[ -n "$ramdisk_compress_format" ]] ; then
            if ! magiskboot cpio "$ramdisk_cpio" extract &> /dev/null; then
                abort
            fi
        fi
        find_args=""
        for needed_add_find_arg in $final_fstab_name ; do
            if [[ -z "$find_args" ]] ; then 
                find_args="-name $needed_add_find_arg"
            else
                find_args+=" -or -name $needed_add_find_arg"
            fi
        done
        for fstab in $(find "$boot_folder/ramdisk_folder/" $find_args); do
            echo "- Patching $(basename $fstab)"
            if grep -q "/vendor/etc/init/hw" "$fstab" ; then
                sed -i '/\/vendor\/etc\/init\/hw/d' "$fstab"
            fi
            if grep -q "/system/etc/init/hw" "$fstab" ; then
                sed -i '/\/system\/etc\/init\/hw/d' "$fstab"
            fi
            [[ -n "$(tail -n 1 "$fstab")" ]] && echo "" >>"$fstab"
            echo "${NAME_INJECT}    /vendor/etc/init/hw ext4    ro,discard  slotselect,logical,first_stage_mount" >>$fstab
            echo "- Adding modified $(basename $fstab) -> $boot"
            magiskboot cpio "$ramdisk_cpio" "add 777 ${fstab//$boot_folder\/ramdisk_folder\//} $fstab" &> /dev/null
        done
        cd $boot_folder
        if [[ -n "$ramdisk_compress_format" ]] ; then
            echo "- Packing ramdisk back into $ramdisk_compress_format"
            magiskboot compress="${ramdisk_compress_format}" "$ramdisk_cpio" "$boot_folder/ramdisk.compress.cpio"
            rm -f "$ramdisk_cpio"
            mv "$boot_folder/ramdisk.compress.cpio" "$ramdisk_cpio"
        fi
        echo "- Repacking $boot"
        magiskboot repack $boot_block &> /dev/null
        echo "- flasing new-$boot -> $boot_block"
        blockdev --setrw $boot_block
        cat $boot_folder/new-boot.img > $boot_block
        rm -rf "$TMPN/ramdisk_patch"
    done
}; export -f ramdisk_first_stage_patch

make_inject_img() {
    TARGET_DIR="$1"
    LABLE="$2"
    SYSTEM_FOLDER_OWNER="$3"
    INJECT_TMP_FOLDER_ONWER="$4"
    FILE_CONTEXTS_FILE="$TMPN/${LABLE}_file_contexts"
    FS_CONFIG_FILE="$TMPN/${LABLE}_fs_config"
    for file in "$FILE_CONTEXTS_FILE" "$FS_CONFIG_FILE" ; do
        [ -f "$file" ] && rm -f "$file"
    done
    {
        find $TARGET_DIR | while read FILE
        do
            if [ -e "$SYSTEM_FOLDER_OWNER${FILE#$TARGET_DIR}" ] && [[ -n "$3" ]] ; then
                OWNER=$(busybox stat -Z "$SYSTEM_FOLDER_OWNER${FILE#$TARGET_DIR}" | awk '/^S_Context/ {print $2}')
                if [ -z "${OWNER}" ] ; then
                    OWNER=$(busybox stat -Z $(dirname "$SYSTEM_FOLDER_OWNER${FILE#$TARGET_DIR}") | awk '/^S_Context/ {print $2}')
                fi
            elif [[ -e "$INJECT_TMP_FOLDER_ONWER${FILE#$TARGET_DIR}" ]] && [[ -n "$4" ]] ; then
                OWNER=$(busybox stat -Z "$INJECT_TMP_FOLDER_ONWER${FILE#$TARGET_DIR}" | awk '/^S_Context/ {print $2}')
                if [ -z "${OWNER}" ] ; then
                    OWNER=$(busybox stat -Z $(dirname "$INJECT_TMP_FOLDER_ONWER${FILE#$TARGET_DIR}") | awk '/^S_Context/ {print $2}')
                fi
            else
                OWNER=$(busybox stat -Z "$FILE" | awk '/^S_Context/ {print $2}')
                if [ -z "${OWNER}" ] ; then
                    OWNER=$(busybox stat -Z $(dirname "$FILE") | awk '/^S_Context/ {print $2}')
                fi
            fi
            FILE_FORMAT=$(echo "${FILE#$TARGET_DIR}" | awk '{ gsub(/\./, "\\."); gsub(/\ /, "\\ "); gsub(/\+/, "\\+"); gsub(/\[/, "\\["); print }')
            if [ -d "${FILE}" ] ; then 
                CONTEXT_LINE="/${LABLE}${FILE_FORMAT}(/.*)? ${OWNER}"
                echo $CONTEXT_LINE >> "${FILE_CONTEXTS_FILE}"
            fi
            CONTEXT_LINE="/${LABLE}${FILE_FORMAT} ${OWNER}"
            if ! [ "${LABLE}${FILE#$TARGET_DIR}" == "${LABLE}" ] ; then
                echo $CONTEXT_LINE >> "${FILE_CONTEXTS_FILE}"
            fi
            
        done
    } & {

        find $TARGET_DIR | while read FILE
        do
            if ! [ "${LABLE}${FILE#$TARGET_DIR}" == "${LABLE}" ] ; then
                if [ -e "$SYSTEM_FOLDER_OWNER${FILE#$TARGET_DIR}" ] && [ -n "$3" ]  ; then
                    PERMISSIONS_GROUPS=$(busybox stat -c "%u %g 0%a" "$SYSTEM_FOLDER_OWNER${FILE#$TARGET_DIR}")
                    LINKER_FILE=$(busybox stat "$SYSTEM_FOLDER_OWNER${FILE#$TARGET_DIR}" | awk -F"'" '/->/ && !found {split($0, arr, "->"); gsub(/^[[:space:]]+|[[:space:]]+$/, "", arr[2]); gsub(/\ /, "\\ ", arr[2]); gsub(/[\047]/, "", arr[2]); print arr[2]; found=1}')
                elif [ -e "$INJECT_TMP_FOLDER_ONWER${FILE#$TARGET_DIR}" ] && [ -n "$4" ]  ; then
                    PERMISSIONS_GROUPS=$(busybox stat -c "%u %g 0%a" "$INJECT_TMP_FOLDER_ONWER${FILE#$TARGET_DIR}")
                    LINKER_FILE=$(busybox stat "$INJECT_TMP_FOLDER_ONWER${FILE#$TARGET_DIR}" | awk -F"'" '/->/ && !found {split($0, arr, "->"); gsub(/^[[:space:]]+|[[:space:]]+$/, "", arr[2]); gsub(/\ /, "\\ ", arr[2]); gsub(/[\047]/, "", arr[2]); print arr[2]; found=1}')
                else
                    PERMISSIONS_GROUPS=$(busybox stat -c "%u %g 0%a" "$FILE")
                    LINKER_FILE=$(busybox stat "$FILE" | awk -F"'" '/->/ && !found {split($0, arr, "->"); gsub(/^[[:space:]]+|[[:space:]]+$/, "", arr[2]); gsub(/\ /, "\\ ", arr[2]); gsub(/[\047]/, "", arr[2]); print arr[2]; found=1}')
                fi
                
                FILE_FORMAT=$(echo "${FILE#$TARGET_DIR}" | awk '{ gsub(/\ /, "\\ "); print }')
                FS_CONFIG_LINE="${LABLE}${FILE_FORMAT} ${PERMISSIONS_GROUPS} ${LINKER_FILE}"
                echo "$FS_CONFIG_LINE" >> "${FS_CONFIG_FILE}"
            fi
            
        done
    }
    wait
    PRESIZE_IMG_FODLER="$(du -sb "${TARGET_DIR}" | awk '{print int($1*10)}')"
    if [[ "$2" == "inject" ]] ; then
        MAKEING_IMG_NAME="$IMG"
    else
        MAKEING_IMG_NAME="$TMPN/$2.img"
    fi
    make_ext4fs -J -T 1230764400 -S "${FILE_CONTEXTS_FILE}" -l $PRESIZE_IMG_FODLER -C "${FS_CONFIG_FILE}" -a "${LABLE}" -L "${LABLE}" "${MAKEING_IMG_NAME}" "${TARGET_DIR}" &> /dev/null || abort
    resize2fs -M -f "$MAKEING_IMG_NAME" &> /dev/null
    resize2fs -M -f "$MAKEING_IMG_NAME" &> /dev/null
    resize2fs -M -f "$MAKEING_IMG_NAME" &> /dev/null
    resize2fs -M -f "$MAKEING_IMG_NAME" &> /dev/null
    if [[ "$2" == "inject" ]] ; then
        resize2fs -f "$MAKEING_IMG_NAME" "$(($(busybox stat -c%s "$MAKEING_IMG_NAME")*2/512))"s &> /dev/null
    fi
}; export -f make_inject_img

check_size_super() {
    SIZE_IMG_FUNC="$1"
    for size_print in 2 4 8 16 32 64 128 ; do
        if (( ( $SIZE_IMG_FUNC + ( 3 * 1024 * 1024 ) ) > ( $size_print * 1024 * 1024 ) )) ; then
            continue
        fi
        if (( $FREE_SIZE_INTO_SUPER >= $size_print * 1024 * 1024 )) ; then
            echo "- There is enough space in super to write inject.img"
            return 0
            break
        else
            echo "- There is not enough space in super to write inject.img"
            echo "- Required ${size_print}mb"
            return 1
        fi
    done

}; export -f check_size_super

test_mount_inject() {
    local PATH_BLOCK="$1"
    echo "- Checking inject mount from new location"
    mkdir -p "$TMPN/test_inject_img_mount"
    if mount -r "$PATH_BLOCK" "$TMPN/test_inject_img_mount" ; then
        umount "$TMPN/test_inject_img_mount"
        return 0
    fi
    if mount -r "$PATH_BLOCK" "$TMPN/test_inject_img_mount" ; then
        umount "$TMPN/test_inject_img_mount"
        return 0
    fi
    if mount -r "$PATH_BLOCK" "$TMPN/test_inject_img_mount" ; then
        umount "$TMPN/test_inject_img_mount"
        return 0
    fi
    if mount -r "$PATH_BLOCK" "$TMPN/test_inject_img_mount" ; then
        umount "$TMPN/test_inject_img_mount"
        return 0
    fi
    return 1
}; export -f test_mount_inject

find_super_partition() {
    for blocksuper in /dev/block/by-name/* /dev/block/bootdevice/by-name/* /dev/block/bootdevice/* /dev/block/* ; do
        if lptools_new --super $blocksuper --get-info &> /dev/null; then
            echo "$blocksuper"
            break
        fi    
    done 
}; export -f find_super_partition

flash_inject_to_super() {
    SIZE_IMG=$(busybox stat -c%s $IMG)
    LPTOOLS_SLOT_SUFFIX="--slot $CURRENT_SLOT --suffix $CURRENT_SUFFIX"

    SUPER_BLOCK=$(find_super_partition)
    echo "- super block: $SUPER_BLOCK"

    lptools_new --super "$SUPER_BLOCK" $LPTOOLS_SLOT_SUFFIX --remove "inject$CURRENT_SUFFIX" &> /dev/null

    FREE_SIZE_INTO_SUPER="$(lptools_new --super "$SUPER_BLOCK" $LPTOOLS_SLOT_SUFFIX --free | grep "Free space" | awk '{print $3}')"
    if ! check_size_super "$SIZE_IMG" ; then
        echo "- Attempting to compress inject.img"
        resize2fs -M -f "$IMG" &> /dev/null
        resize2fs -M -f "$IMG" &> /dev/null
        resize2fs -M -f "$IMG" &> /dev/null
        SIZE_IMG=$(busybox stat -c%s $IMG)
        if ! check_size_super "$SIZE_IMG" ; then
            return 1
        fi
    fi
    if lptools_new --super $SUPER_BLOCK $LPTOOLS_SLOT_SUFFIX --create "${NAME_INJECT}${CURRENT_SUFFIX}" "$SIZE_IMG" &> /dev/null; then
        echo "- Marking inject with size $(awk 'BEGIN{printf "%.1f:", '$SIZE_IMG'/1024/1024}')MB"
        if find_block -c -b "${NAME_INJECT}${CURRENT_SUFFIX}"; then
            cat "$IMG" > "$(find_block -b "${NAME_INJECT}${CURRENT_SUFFIX}")"
            if test_mount_inject "$(find_block -b "${NAME_INJECT}${CURRENT_SUFFIX}")"; then
                echo "- Success writing inject to super"
            else
                echo "- Failed to mount created partition"
                return 1
            fi
        else
            echo "- Failed to find created partition"
            return 1
        fi
    else
        echo "- Failed to create partition"
        return 1
    fi
    return 0

}; export -f flash_inject_to_super

find_block() {
    found_blocks=()
    block_names=()
    check_status_o=false
    while [ $# -gt 0 ]; do
        case "$1" in
            -c)
                check_status_o=true
                shift 1
            ;;
            -b)
                shift 1
                if [[ $# -gt 0 && ${1:0:1} != "-" ]]; then
                    while [[ $# -gt 0 && ${1:0:1} != "-" ]]; do
                        block_names+=("$1")
                        shift 1
                    done
                fi
            ;;
            *)
                exit 1
            ;;
        esac
    done

    for block in "${block_names[@]}"; do
        if [ -h /dev/block/by-name/$block ]; then
            if ! [ -h "$(readlink /dev/block/by-name/$block)" ] && [ -b "$(readlink /dev/block/by-name/$block)" ]; then
                found_blocks+="$(readlink /dev/block/by-name/$block) "
            fi
        elif [ -b /dev/block/mapper/$block ]; then
            if ! [ -h "$(readlink /dev/block/mapper/$block)" ] && [ -b "$(readlink /dev/block/mapper/$block)" ]; then
                found_blocks+="$(readlink /dev/block/mapper/$block) "
            fi
        elif [ -h /dev/block/bootdevice/by-name/$block ]; then

            if ! [ -h "$(readlink /dev/block/bootdevice/by-name/$block)" ] && [ -b "$(readlink /dev/block/bootdevice/by-name/$block)" ]; then
                found_blocks+="$(readlink /dev/block/bootdevice/by-name/$block) "
            fi
        fi
    done
    if [[ -z "$found_blocks" ]] ; then
        return 1
    else
        if $check_status_o ; then
            return 0
        else
            echo "${found_blocks% *}"
        fi
    fi
}; export -f find_block

abort(){
    lptools_new --super "$SUPER_BLOCK" $LPTOOLS_SLOT_SUFFIX --remove "inject$CURRENT_SUFFIX" &> /dev/null
    umount_vendor
    rm -rf "$TMPN"
    echo "Mission DFE aborted"
    exit
}; export -f abort

move_fstab_from_original_vendor_and_patch() {
    original_fstab_name_for="$(basename "$1")"
    full_path_to_fstab_into_for="$1"
    echo "- fstab name: $original_fstab_name_for"
    if [[ -f "$full_path_to_fstab_into_for" ]] && grep "/userdata" "$full_path_to_fstab_into_for" | grep "latemount" | grep -q -v "#"; then
        echo "- Copying fstab to inject"
        if [[ -f "$TMPN/inject${CURRENT_SUFFIX}/$original_fstab_name_for" ]] ; then
            echo "- Found $TMPN/inject${CURRENT_SUFFIX}/$original_fstab_name_for"
            return 20
        else
            echo "- Patching inject${CURRENT_SUFFIX}/$original_fstab_name_for"
            cp -af "$full_path_to_fstab_into_for" "$TMPN/inject${CURRENT_SUFFIX}/$original_fstab_name_for"
            patch_fstab $FSTAB_PATCH_PATERNS -f "$full_path_to_fstab_into_for" -o "$TMPN/inject${CURRENT_SUFFIX}/$original_fstab_name_for"
            return 10
        fi
    fi
    return 30
}; export -f move_fstab_from_original_vendor_and_patch

patch_fstab() {
    removeoverlay=false
    removepattern=""
    input_fstab=""
    mountpoint=""
    output_fstab=""
    while [ $# -gt 0 ]; do
        case "$1" in
        -m) 
            removepattern="$removepattern $2--m--"
            shift 2
            while [[ "$1" != "-m" && "$1" != "-f" && "$1" != "-o" && "$1" != "-v" ]] && [ $# -gt 0 ]; do 
                case "$1" in 
                    -r|-p)
                        now_check_pattern="$1"
                        shift 1
                        if [ $# -gt 0 ] && [ "$(printf '%s' "$1" | cut -c 1)" != "-" ]; then
                            while [ $# -gt 0 ] && ( [ "$(printf '%s' "$1" | cut -c 1)" != "-" ] ); do
                                removepattern="${removepattern}-$now_check_pattern--$1-$now_check_pattern--"
                                shift 1
                            done
                        else
                            echo "No patterns provided for removal."
                        fi
                    ;;
                esac
            done
            ;;
        -f) 
            input_fstab="$2"
            shift 2
            ;;
        -o) 
            output_fstab="$2"
            if [[ "$output_fstab" == "fstab\*" ]] ; then
                exit 192
            fi
            shift 2
            ;;
        -v) 
            removeoverlay=true
            shift 1
            ;;
        *)  
            echo "Unknown parameter: $1"
            exit 1
            ;;
        esac
    done
    echo -n "" > "$output_fstab"
    while IFS= read -r line; do
        if $removeoverlay; then
            case $line in
                overlay*)
                    line="#$line"
                    ;;
            esac
        fi
        case $line in 
            "# "*)
            ;;
            *)
                if [ "$(echo "$removepattern" | wc -w)" -gt 0 ]; then
                    for arrp in $removepattern ; do
                        mountpoint=${arrp%%"--m--"*}
                        patterns=${arrp##*"--m--"}
                        remove_paterns=$(echo -e ${patterns//"--p--"/"\n"} | grep "\-\-r--")
                        replace_patterns=$(echo -e ${patterns//"--r--"/"\n"} | grep "\-\-p--")
                        if [ "$(echo "$line" | awk '{print $2}')" == "$mountpoint" ]; then
                            echo "- Mounting point detected: '$mountpoint'"
                            for replace_pattern in ${replace_patterns//"--p--"/ } ; do
                                if echo "$line" | grep -q "${replace_pattern%%"--to--"*}" ; then
                                    echo "- Replacement completed ${replace_pattern%%"--to--"*}->${replace_pattern##*"--to--"}"
                                    line=$(echo "$line" | sed -E "s/,${replace_pattern%%"--to--"*}*[^[:space:]|,]*/,${replace_pattern##*"--to--"}/")
                                fi
                                if echo "$line" | grep -q "${replace_pattern%%"--to--"*}" && ! (echo "$line" | grep -q "${replace_pattern##*"--to--"}"); then 
                                    echo "- Replacement completed ${replace_pattern%%"--to--"*}->${replace_pattern##*"--to--"}"
                                    line=$(echo "$line" | sed -E "s/${replace_pattern%%"--to--"*}*[^[:space:]|,]*/${replace_pattern##*"--to--"}/")
                                fi 
                            done
                            for remove_pattern in ${remove_paterns//"--r--"/ }; do
                                if echo "$line" | grep -q "${remove_pattern}" ; then 
                                    echo "- Flag removed: ${remove_pattern}"
                                    line=$(echo "$line" | sed -E "s/,${remove_pattern}*[^[:space:]|,]*//")
                                fi
                                if echo "$line" | grep -q "${remove_pattern}" ; then 
                                    echo "- Flag removed: ${remove_pattern}"
                                    line=$(echo "$line" | sed -E "s/${remove_pattern}*[^[:space:]|,]*//")
                                fi
                            done
                        fi


                    done
                fi
            ;;
        esac
        echo "$line" >>"$output_fstab"
    done <"$input_fstab"

}; export -f patch_fstab

install_dfe
umount_vendor
rm -rf "$TMPN"
